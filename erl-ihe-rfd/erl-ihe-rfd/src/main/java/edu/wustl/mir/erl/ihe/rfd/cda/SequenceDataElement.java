/*******************************************************************************
 * Copyright (c) 2015 Washington University in St. Louis All rights reserved.
 * This program and the accompanying materials are made available under the
 * terms of the Apache License, Version 2.0 (the "License"); you may not use
 * this file except in compliance with the License. The License is available at:
 * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
 * or agreed to in writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License. Contributors:
 * Initial author: Ralph Moulton / MIR WUSM IHE Development Project
 * moultonr@mir.wustl.edu
 ******************************************************************************/
package edu.wustl.mir.erl.ihe.rfd.cda;

import java.util.ArrayList;
import java.util.List;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;

import org.apache.commons.lang3.StringUtils;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import edu.wustl.mir.erl.ihe.util.Util;
import edu.wustl.mir.erl.ihe.ws.db.WSLog;

/**
 * Generic sequencer, wraps other DataElements which may have multiple values.
 * The {@link #xpathExpression} is used to generate a {@link NodeList}, which
 * the SequenceDataElement then iterates, computing values for the
 * {@link DataElement} or subtype 'T'. There are three types of sequences,
 * controlled by {@link #sequenceType}.
 * <ul>
 * <li>{@link SequenceType#ALL ALL}. Every node in the NodeList generates an
 * instance of 'T' with its own values. The instances are created by copying the
 * passed 'T' {@link #dataElement}, adding a sequence (see below) to the
 * original {@link #parName} and {@link #element} to distinguish the instances.
 * ALL is the default sequence type; Other sequence types must be set using
 * {@link #setSequenceType}.</li>
 * <li>{@link SequenceType#SOME SOME}. Zero or more nodes in the NodeList
 * generate instances of 'T' with their own values. The instances are created in
 * the same manner as the ALL sequence type, except that a trigger (see below)
 * is used to determine if the particular instance of 'T' for this Node should
 * be included or ignored.</li>
 * <li>{@link SequenceType#ANY ANY}. One instance of 'T' will be generated, with
 * the value of 'T' generated by the first node in the list that 'fires' the
 * trigger, after which the rest of the NodeList is ignored. If no node in the
 * list 'fires' the trigger, the 'T' instance will have its default value. In
 * ANY sequences, no sequence is added to the {@link #parName} and
 * {@link #element} of the passed {@link #dataElement}, as this is not needed.
 * </li>
 * </ul>
 * <b>Usage:</b>
 * <ol>
 * <li>Create an 'empty' instance of the DataElement you wish to sequence,
 * including {@link #parName}, {@link #element} and {@link #description}. The
 * {@link #xpathExpression} gives the XPath within the individual nodes in the
 * NodeList; If blank, the nodes in the NodeList will be used directly. For
 * example:
 * 
 * <pre>
 * {@code
 * CODDataElement emptyDataElement = new CODDataElement(
     getXPath(),
     "causeOfDeath",
     "Cause of Death",
     "Cause of Death and corresponding onsetToDeathInterval interval",
     "")}
 * </pre>
 * 
 * </li>
 * <li>Pass that instance to the SequenceDataElement constructor, along with its
 * other parameters. The {@link #xpathExpression} here should return a NodeList
 * which will be iterated over by the SequenceDataElement. For example:
 * 
 * <pre>
 * {
 *    &#64;code
 *    SequenceDataElement seqDataElement = new SequenceDataElement <CODDataElement>(getXPath(), "causesOfDeath",
 *       "Cause(s) of Death", "Cause(s) of Death and corresponding onsetToDeathInterval intervals",
 *       "//nl:section[nl:... observation/nl:code[@code='21984-0']]", emptyDataElement);
 * }
 * </pre>
 * 
 * </li>
 * <li>If there is a sequence in the nodes that you want appended to the
 * {@link #parName} and {@link #element} to distinguish the instances, inject it
 * using {@link #setSequenceXpathExpression(String)}. for example:
 * 
 * <pre>
 * {@code
 *    seqDataElement.setSequenceXpathExpression("./nl:sequenceNumber/@value")
 *    }
 * </pre>
 * 
 * This is optional. If not set, a simple counter will be appended to the
 * parName and element, for example, "causeOfDeath-1".</li>
 * <li>For SequenceType ALL and SOME, an instance of a class implementing the
 * {@link DataElementCopy} interface for the DataElement type being sequenced
 * MUST be passed using {@link #setCopy(DataElementCopy)}. This is not needed
 * for SequenceType ANY, and would be ignored. For example:
 * 
 * <pre>
 * {@code
 *    seqDataElement.setCopy(new CODDataElement.Copy())}
 * </pre>
 * 
 * </li>
 * <li>For SequenceType SOME and ANY an instance of a class implementing the
 * {@link Trigger} interface to indicate when a DataElement should be generated.
 * By default, DataElement will be generated if the computed value is non-null.
 * For example:
 * 
 * <pre>
 * seqDataElement.setTrigger(new Trigger() { public boolean trigger(String
 * value) { if (value.equalsIgnoreCase("Y") return true; return false; };});}
 * 
 * <pre>
 * </li>
 * </ol>
 * 
 * @param <T> The Type, DataElement or subclass, which is to be sequenced.
 */
public class SequenceDataElement <T extends DataElement> extends DataElement {
   private static final long serialVersionUID = 1L;

   /**
    * The DataElements created during the processing of the Sequence
    */
   protected List <T> dataElements = new ArrayList <>();

   /**
    * {@link SequenceType} of this sequence. Default is {@link SequenceType#ALL
    * ALL}
    */
   protected SequenceType sequenceType = SequenceType.ALL;

   /**
    * XPath expression relative to xpathExpression which gives the sequencing
    * value, or blank if no sequencing is used.
    */
   protected String sequenceXpathExpression = "";

   /**
    * An instance of the {@link DataElement} or subtype being sequenced.
    */
   protected T dataElement;
   /**
    * Instance of a class which implements the {@link DataElementCopy} interface
    * for the DataType being sequenced.
    */
   DataElementCopy <T> copy = null;

   /**
    * For {@link SequenceType#SOME SOME} and {@link SequenceType#ANY ANY}
    * sequences, the function which will trigger the generation of a
    * DataElement. By default, an element is generated if its computed value is
    * non null.
    */
   protected Trigger triggerFunction = new Trigger() {
      @Override
      public boolean trigger(DataElement dataElemnt, StringBuilder msg) {
         if (dataElemnt.getValue() == null) {
        	 msg.append(" null data element");
        	 return false;
         }
         return true;
      };
   };

   /**
    * @param xpath The {@link XPath} api to use with this data element.
    * @param parName the {@link #parName} value.
    * @param element the {@link #element} value
    * @param description the {@link #description} value
    * @param xpathExpression the {@link #xpathExpression} value which returns a
    * NodeList of the repeating node.
    * @param dataElement the {@link #dataElement} value.
    */
   public SequenceDataElement(XPath xpath, String parName, String element, String description, String xpathExpression,
      T dataElement) {
      super(xpath, parName, element, description, xpathExpression);
      value = "";
      this.dataElement = dataElement;
   }
   
   /**
    * Sets {@link #sequenceXpathExpression}. Default is none, use simple count.
    * 
    * @param expr XPath expression for the sequence value
    * @return this SequenceDataElement, for method chaining
    */
   public SequenceDataElement <T> setSequenceXpathExpression(String expr) {
      sequenceXpathExpression = expr;
      return this;
   }

   /**
    * Set the {@link #copy} for the {@link DataElement} or subtype. Required.
    * 
    * @param copy {@link #copy} instance for the data type being sequenced.
    * @return this SequenceDataElement, for method chaining.
    */
   public SequenceDataElement <T> setCopy(DataElementCopy <T> copy) {
      this.copy = copy;
      return this;
   }

   /**
    * Set the {@link #sequenceType} value. This should be done when the
    * {@link SequenceDataElement} is created.
    * 
    * @param type {@link SequenceType} to set
    * @return this SequenceDataElement, for method chaining.
    */
   public SequenceDataElement <T> setSequenceType(SequenceType type) {
      sequenceType = type;
      return this;
   }

   /**
    * Set {@link #triggerFunction}
    * 
    * @param trigger instance of class implementing {@link Trigger} interface.
    * @return this SequenceDataElement, for method chaining.
    */
   public SequenceDataElement <T> setTrigger(Trigger trigger) {
      triggerFunction = trigger;
      return this;
   }
   /**
    * @return Trigger function for this Sequence dataElement.
    */
   public Trigger getTrigger() {
      return triggerFunction;
   }

   /**
    * @return count of Sequenced DataElement
    */
   public Integer getCount() {
      return dataElements.size();
   }
   
   @Override
   public SequenceDataElement<T> loadSnippet(String key) {
      super.loadSnippet(key);
      return this;
   }

   @Override
   public  SequenceDataElement<T> setSnippet(String snippet) {
      super.setSnippet(snippet);
      return this;
   }
   
   /**
    * routine for Sequence Data Elements adds insert of contained data elements
    * in string.
    */
   @Override
   public String getResolvedSnippet() {
      String ws = snippet;
      if (ws.contains("[DATAELEMENTS]")) {
         StringBuilder des = new StringBuilder();
         for(DataElement de : dataElements) 
            des.append(de.getResolvedSnippet()).append(nl);
         ws = StringUtils.replace(snippet, "[DATAELEMENTS]", des.toString());
      }
      return StringUtils.replace(ws, "[PN]", parName);
   }

   /**
    * @return the List of Sequenced DataElements as array of DataElement
    */
   public DataElement[] getDataElements() {
      DataElement[] rdes = new DataElement[dataElements.size()];
      for (int i = 0; i < dataElements.size(); i++ ) {
         rdes[i] = dataElements.get(i);
      }
      return rdes;
   }

   @Override
   public void loadValue(Element element2) throws Exception {

      dataElements = new ArrayList <>();

      StringBuilder msg = new StringBuilder("Load Sequence: " + parName);

      NodeList nodes = (NodeList) evaluate(element2, xpathExpression, XPathConstants.NODESET);
      if (nodes == null) {
         msg.append(": node list not found");
         log.debug(msg);
         return;
      }
      if (nodes.getLength() == 0) {
         msg.append(": node list empty");
         log.debug(msg);
         return;
      }
      msg.append(" " + nodes.getLength() + " nodes found");
      // ------------------ pass repeating nodes
      for (int i = 0; i < nodes.getLength(); i++ ) {
    	 msg.append(nl + "node " + i);
         Node node = nodes.item(i);
         if (node == null || node.getNodeType() != Node.ELEMENT_NODE) {
        	 msg.append(" not an element");
        	 continue;
         }
         Element elmt = (Element) node;
         msg.append(" " + elmt.getNodeName() + " element");
         
         // load the dataElement from this node
         T newDataElement = copy.copy(dataElement);
         newDataElement.loadValue(elmt);
         // If we don't want it, skip it.
         if (sequenceType != SequenceType.ALL &&
             triggerFunction.trigger(newDataElement, msg) == false) { 
        	 msg.append(" - not selected.");
        	 continue;
         }
         msg.append(" - selected");

         // Do want it. Make a sequence if we want that.
         if (sequenceType != SequenceType.ANY) {
            String nodeSequence = Integer.toString(dataElements.size() + 1);
            if (StringUtils.isNotBlank(sequenceXpathExpression)) {
               try {
                  String s = (String) evaluate(elmt, sequenceXpathExpression, XPathConstants.STRING);
                  if (StringUtils.isNotBlank(s)) nodeSequence = s;
               } catch (Exception e) {
                  log.warn(Util.getEM(e));
               }
            }
            newDataElement.sequence("-" + nodeSequence);
            msg.append(" sequence " + nodeSequence);
         }
         // --------------------- add the new data element to the list.
         log.debug(newDataElement.getParName());
         dataElements.add(newDataElement);
         // For Any type sequences, when we find one data element, we're done
         if (sequenceType == SequenceType.ANY) { 
        	 log.debug(msg);
        	 return;
         }
      } // EO pass nodes
      log.debug(msg);
   } // EO load value 

   @Override
   public void loadWSLog(WSLog wsLog) {   
      for (T de : dataElements) {
         de.loadWSLog(wsLog);
      }
   }

   /**
    * Indicates the type of sequence being processed.
    */
   public enum SequenceType {

      /**
       * Every node in the sequence contains an instance of the DataElement,
       * even if the value is null or empty. Trigger value is not used.
       */
      ALL, 
      /**
       * 0 or more of the nodes in the sequence contain an instance of the
       * DataElement. The trigger value is used to determine if the value
       * in a particular node 'counts' or not.
       */
      SOME,
      /**
       * Used when looking to see if a value exists in any of the nodes in
       * the sequence. If not, the DataElement returns its default value.
       * If so, the DataElement returns the value computed for the first
       * node in the sequence to match the trigger, with the rest of the
       * nodes in the sequence being ignored.
       */
      ANY
   }

} // EO SequenceDataElement class
